# 학습 내용 이해도 자가 진단표

## 프로그래밍 개론

#### 컴퓨터와 소프트웨어

- [ ] 컴퓨터와 소프트웨어의 관계를 이해한다.
- [ ] 시스템 소프트웨어와 응용 소프트웨어를 구분할 수 있다.

#### 프로그램의 구동 원리

- [ ] 컴퓨터에서 프로그램이 실행되는 원리를 이해한다.
- [ ] CPU(ARM CPU 기준) 인스트럭션이 무엇인지 이해한다. `http://vision.gel.ulaval.ca/~jflalonde/cours/1001/h17/docs/arm-instructionset.pdf`
- [ ] CPU 인스트럭션과 실행 파일, OS의 관계를 이해한다.
- [ ] 같은 CPU에 맞춰 작성된 실행 파일이더라도 OS가 다르면 실행되지 않는 이유를 설명할 수 있다.

#### 중간 언어와 가상 머신

- [ ] 중간 언어와 가상 머신이 등장한 이유와 이점을 설명할 수 있다.
- [ ] VM과 인터프리터, 런타임, 플레이어, 엔진의 역할을 이해한다.
- [ ] JIT(Just-in-time)과 AOT(ahead-of-time)이 무엇이고 등장한 이유를 이해한다.

#### 자바 바이트코드와 자바 가상 머신

- [ ] 자바 바이트코드 실행 환경을 준비할 수 있다. OpenJDK 설치, JAVA_HOME 과 PATH 환경 변수 설정, Sublime 편집기 설치.
- [ ] 자바 바이트코드를 이해한다. `https://docs.oracle.com/javase/specs/jvms/se13/jvms13.pdf`
- [ ] 바이트코드와 클래스 파일(.class)의 관계를 이해한다. `/HelloWorld.class`, `https://medium.com/@davethomas_9528/writing-hello-world-in-java-byte-code-34f75428e0ad`
- [ ] 클래스 파일과 JVM의 관계를 이해한다. `$ javap HelloWorld.class`, `$ javap -verbose HelloWorld.class`
- [ ] JVM을 이용하여 클래스 파일을 실행할 수 있다. $ java HelloWorld

#### 프로그래밍 언어와 컴파일

- [ ] 컴파일 방식 프로그래밍이 등장한 이유를 이해한다.
- [ ] 프로그래밍 언어와 컴파일, CPU 인스트럭션의 관계를 이해한다.
- [ ] 컴파일러를 이용하여 소스 코드(C 프로그래밍 언어 기준)를 목적 코드(CPU 인스트럭션)로 생성하는 과정을 이해한다. `/module.c`, `/main.c`, `$ gcc -c 소스파일`
- [ ] 링커(C 프로그래밍 언어 기준)를 이용하여 목적 코드가 들어 있는 파일을 하나로 묶어 실행 파일을 만드는 과정을 이해한다. `$ ld -o 실행파일 목적파일 목적파일 … -lSystem -macosx_version_min 10.13`
- [ ] C 프로그래밍 언어 기준, "소스 파일, 목적파일, 실행 파일"과 "컴파일러, 링커"의 관계를 이해한다. 

#### 컴파일러와 인터프리터

- [ ] 인터프리트 방식 프로그래밍과 실행 과정을 이해한다.
- [ ] Node.js 자바스크립트 인터프리터를 준비할 수 있다. `https://nodejs.org/en/`
- [ ] 인터프리터(Node.js 기준)를 사용하여 소스 파일을 직접 실행하는 과정을 이해한다. `/hello.js`, `$ node hello.js`
- [ ] 컴파일 방식과 인터프리트 방식의 구동 원리를 이해한다.
- [ ] 컴파일 방식과 인터프리트 방식의 장단점을 비교할 수 있다.

#### 자바 프로그래밍 절차

- [ ] 자바의 프로그래밍 방식과 실행 원리를 이해한다.
- [ ] 자바 코드와 바이트코드, 소스 파일과 클래스 파일의 관계를 이해한다.
- [ ] 자바 컴파일러와 JVM의 역할을 이해한다.
- [ ] CLI 환경에서 컴파일을 수행할 수 있다. `/Hello.java`, `$ javac Hello.java`
- [ ] CLI 환경에서 자바 클래스 파일을 실행할 수 있다. `/Hello.java`, `$ java Hello`

#### 소스 파일과 컴파일 결과 파일 분리

- [ ] Maven 표준 디렉토리 구조를 만들 수 있다. Maven 표준 디렉토리 구조에 맞춰 폴더를 생성한다.
- [ ] 각 디렉토리의 용도를 이해한다.
- [ ] 프로젝트 디렉토리에서 소스 디렉토리에 있는 자바 소스 파일을 컴파일 할 수 있다. `src/main/java/Hello2.java`, `$ javac src/main/java/Hello2.java`
- [ ] 컴파일 할 때 컴파일 결과로 생성된 클래스 파일을 별도 디렉토리에 분리할 수 있다. `src/main/java/Hello2.java`, `$ javac -d bin/main src/main/java/Hello2.java`
- [ ] 다른 디렉토리에 있는 클래스 파일을 실행할 수 있다. `src/main/java/Hello2.java`, `$ java -classpath bin/main Hello2`

#### 패키지와 소스 파일

- [ ] 패키지의 용도를 이해하고 패키지를 생성할 수 있다. `com.ohoracs.basic`, `src/main/java/com/ohoracs/basic 디렉토리 생성`
- [ ] 소스 파일에 작성한 코드가 패키지에 소속되게 할 수 있다. `src/main/java/com/ohoracs/basic/Hello3.java`
- [ ] 패키지에 소속된 소스 파일의 적절한 디렉토리 경로와 왜 그 위치에 놓아야 하는지 이해한다.
- [ ] 컴파일 한 후 생성된 클래스 파일의 디렉토리 경로와 그 위치에 있어야 하는 이유를 안다.
- [ ] 패키지에 소속된 클래스 파일을 실행할 수 있다. `src/main/java/com/ohoracs/basic/Hello3.java`, `$ java -cp bin/main com.ohoracs.basic.Hello3`
- [ ] 패키지를 적용하지 않은 채로 그 소스 파일을 그냥 패키지 폴더에 둔다면 컴파일 할 때 어떤 문제가 발생하는지 안다. `src/main/java/com/ohoracs/basic/Hello4.java`

#### Gradle 빌드 도구

- [ ] Gradle 빌드 도구를 이용하여 작업 폴더를 자바 프로젝트 폴더로 구성할 수 있다. `/프로젝트폴더`, `$ gradle init`
- [ ] Gradle로 생성된 src 디렉토리의 구조를 이해하고 설명할 수 있다. `/src`
- [ ] src 디렉토리 외에 다른 디렉토리나 파일의 용도를 이해한다.

## 자바 기초 문법 - com.ohoracs.basic

#### 클래스 블록과 컴파일, 실행

- [ ] 소스 파일(.java)과 클래스 블록(class 클래스명 {…}), 클래스 파일(.class) 관계를 이해한다. `ex01/Exam11.java`
- [ ] 한 소스 파일에 여러 개의 클래스 블록이 있을 때 컴파일하면 어떻게 되는지 안다. `ex01/Exam12.java`
- [ ] 클래스의 사용 범위(공개/비공개)에 따라 소스 파일과 클래스 블록의 이름이 어떤 관계가 있는지 안다. `ex01/Exam21.java, Exam22.java, Exam23.java`
- [ ] 컴파일 할 때 소스 파일의 인코딩을 지정할 수 있다. `ex01/Exam3.java`
- [ ] JVM이 클래스를 실행하는 과정을 이해하고 설명할 수 있다.
- [ ] main() 메서드의 용도를 알고 있으며 작성할 수 있다. `ex01/Exam4.java`

#### 주석

- [ ] 자바 소스 코드에 주석을 달 수 있다. `ex02/Exam1.java`
- [ ] 주석(`//, /* … */`)의 종류와 작성법을 안다. `ex02/Exam1.java`
- [ ] Javadoc 주석(`/** … */`)의 용도를 이해하고 이 주석을 이용하여 HTML 문서를 생성(`javadoc 사용`)할 수 있다. `ex02/Exam2.java`
- [ ] 애노테이션(`@Override`)의 용도와 문법을 이해한다. `ex02/Exam3.java`

#### 데이터 종류에 따른 리터럴 표기법

- [ ] `정수, 부동소수점, 논리, 문자, 문자열` 리터럴 문법의 용도를 이해한다. `ex03/Exam1.java`
- [ ] 정수 리터럴을 10진수, 8진수, 2진수, 16진수로 표현할 수 있다. `ex03/Exam21.java`
- [ ] 문자 '_' 를 사용하여 정수 리터럴의 자릿수를 표현할 수 있고, _ 문자의 적절한 위치를 안다. `ex03/Exam22.java`
- [ ] 메모리에 값을 저장하기 위해 데이터를 2진수로 변환해야 하는 이유를 설명할 수 있다.
- [ ] 메모리 크기에 따라 정수를 저장할 수 있는 범위가 다른 이유를 이해한다.
- [ ] 메모리 크기에 따라 정수 리터럴을 4바이트와 8바이트로 구분하여 표현할 수 있다. `ex03/Exam23.java`
- [ ] 정수 리터럴이 메모리 크기를 벗어날 때 어떤 문제가 발생하는지 안다. `ex03/Exam23.java`
- [ ] 정수 리터럴이 메모리에 어떻게 저장되는지 이해한다. `ex03/Exam24.java`
- [ ] 정수를 2진수로 표현하는 다양한 방법을 이해한다. (Sign-magnitude, 1의 보수, 2의 보수, Excess-K 방식)
- [ ] 부동소수점 리터럴을 다양한 방식으로 표기할 수 있다. `ex03/Exam31.java`
- [ ] 메모리 크기에 따라 부동소수점 리터럴을 4바이트와 8바이트로 구분하여 표현할 수 있다.`ex03/Exam32.java
- [ ] 메모리 크기에 따라 부동소수점의 최소/최대 크기를 알아낼 수 있다. `ex03/Exam33.java`
- [ ] 부동소수점이 메모리에 저장되는 원리를 이해한다. (IEEE 754 규칙에 따라 부동소수점이 2진수로 변환되는 것을 이해한다.) `ex03/Exam34.java`
- [ ] 부동소수점이 때론 완전하게 2진수로 변환되지 못하는 이유를 안다.
- [ ] 자바에서 부동소수점을 IEEE 754 규칙에 따라 2진수로 변환된 것을 확인해 볼 수 있다. `ex03/Exam35.java`
- [ ] 문자 리터럴을 다양한 방식으로 표기할 수 있다. `ex03/Exam41.java`
- [ ] 문자 집합(character set), 유니코드, UCS, UTF, UTF-8, UTF-16의 의미를 이해한다. `ex03/Exam42.java`
- [ ] ASCII, ISO-8859-1, EUC-KR, 조합형, MS949, Unicode의 의미를 이해한다.
- [ ] UCS(ISO 10646)를 UTF-8로 바꾸는 규칙을 이해한다.
- [ ] UCS 대신 UTF-8이 사용되는 이유를 안다.
- [ ] 문자를 다룰 때 작은 따옴표('')의 의미를 이해한다. `ex03/Exam43.java`
- [ ] 논리 리터럴을 표현할 수 있다. `ex03/Exam5.java`
- [ ] 문자열 리터럴을 표현할 수 있다. `ex03/Exam6.java`
- [ ] 문자열과 다른 유형의 데이터를 결합할 때 어떤 결과가 발생하는지 안다. `ex03/Exam6.java`
- [ ] 이스케이스 문자의 역할과 사용법을 안다. `ex03/Exam7.java`

#### 변수

- [ ] 변수를 선언할 수 있다. `ex04/Exam11.java`
- [ ] 변수 선언의 의미를 설명할 수 있다. `ex04/Exam11.java`
- [ ] 여러 개의 변수를 한 문장으로 선언할 수 있다. `ex04/Exam111.java`
- [ ] 변수가 가리키는 메모리에 값을 저장할 수 있다. `ex04/Exam12.java`
- [ ] 변수 선언할 때 값을 저장할 수 있다. `ex04/Exam121.java`
- [ ] 한 문장으로 여러 개의 변수를 선언할 때에도 값을 저장할 수 있다. `ex04/Exam122.java`
- [ ] 한 문장으로 여러 개의 변수를 선언할 때 일부 변수만 값을 저장할 수 있다. `ex04/Exam123.java`
- [ ] 변수가 가리키는 메모리의 값을 변경할 수 있다. `ex04/Exam13.java`
- [ ] 블록 안에서 변수를 선언할 수 있는 위치를 안다. `ex04/Exam14.java`
- [ ] 변수를 먼저 사용하고 그 다음에 변수를 선언할 때 발생하는 문제를 안다. `ex04/Exam141.java`
- [ ] 같은 이름의 변수를 중복해서 선언할 때 발생하는 문제를 안다. `ex04/Exam142.java`
- [ ] 변수의 값을 출력할 수 있다. `ex04/Exam15.java`
- [ ] 변수의 값을 다른 변수에 저장할 수 있다. `ex04/Exam151.java`
- [ ] 변수를 초기화시키지 않은 후 사용하면 어떻게 되는지 안다. `ex04/Exam152.java,Exam153.java`
- [ ] 값의 종류에 따라 변수를 선언할 수 있다. `ex04/Exam16.java`
- [ ] primitive data type을 데이터 유형에 따라 크기에 따라 구분할 수 있다. `ex04/Exam16.java`
- [ ] primitive data type 과 referece type을 구분할 수 있다. `ex04/Exam16.java`
- [ ] 정수 데이터 타입(byte, short, int, long)의 각 변수의 메모리 크기와 이 메모리에 저장할 수 있는 최대, 최소 값을 안다. `ex04/Exam21.java`
- [ ] 4바이트와 8바이트 크기의 정수 리터럴을 각 타입의 변수에 저장할 때 규칙을 이해한다. `ex04/Exam22.java`
- [ ] 작은 메모리에 큰 메모리의 값을 넣을 때 어떤 일이 일어나는지 안다. `ex04/Exam23.java`
- [ ] 4바이트 부동소수점 변수에 넣을 수 있는 값의 최대, 최소 크기를 말할 수 있다. `ex04/Exam31.java`
- [ ] 8바이트 부동소수점 변수에 넣을 수 있는 값의 최대, 최소 크기를 말할 수 있다. `ex04/Exam311.java`
- [ ] 단정도, 배정도의 용어를 이해한다. `ex04/Exam311.java`
- [ ] 부동소수점 리터럴의 크기에 따라 적절할 부동소수점 변수를 선언할 수 있다. `ex04/Exam32.java`
- [ ] 잘못된 부동소수점 리터럴을 변수에 저장할 때 어떤 문제가 발생하는지 이해한다. `ex04/Exam321.java`
- [ ] 부동소수점 변수끼리 연산할 때 결과가 부동소수점의 크기를 벗어날 경우 발생되는 문제를 안다. `ex04/Exam322.java`
- [ ] 작은 부동소수점 메모리에 큰 부동소수점 메모리의 값을 넣을 때 발생되는 문제는 안다. `ex04/Exam33.java`
- [ ] UCS-2에 정의된 문자 코드를 저장할 변수를 선언할 수 있다. `ex04/Exam41.java`
- [ ] char 변수에 저장할 수 있는 최대, 최소 값을 말 할 수 있다. `ex04/Exam41.java`
- [ ] char 변수에 문자의 UCS-2 코드 값을 저장하고 출력할 수 있다. `ex04/Exam42.java`
- [ ] char 변수에 저장된 문자 코드를 화면에 출력할 때 문자로 표현하는 과정을 설명할 수 있다. `ex04/Exam42.java`
- [ ] 따옴표를 활용하여 문자의 UCS-2 코드 값을 알아낼 수 있다. `ex04/Exam43.java`
- [ ] 정수를 UCS-2 문자 코드로 인식하게 하여 문자를 출력할 수 있다. `ex04/Exam44.java`
- [ ] 논리 값을 담을 변수를 선언할 수 있다. `ex04/Exam51.java`
- [ ] boolean 변수를 JVM 내부에서는 4바이트 int 메모리로 다룬다는 것을 이해한다. `ex04/Exam51.java`
- [ ] boolean 변수에 직접 1과 0을 넣을 수 없음을 안다. `ex04/Exam51.java`
- [ ] 배열 문법을 이용하여 같은 타입의 메모리를 여러 개 선언할 수 있다. `ex04/Exam61.java`
- [ ] 배열 메모리에 접근할 수 있다. `ex04/Exam611.java`
- [ ] 배열 메모리에 접근할 때 인덱스의 유효 범위를 안다. `ex04/Exam611.java`

